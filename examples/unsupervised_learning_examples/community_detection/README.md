# Community Detection (Label Propagation)

This folder showcases the use of the unsupervised label propagation algorithm on a sample dataset for community detection. This README contains a description of the label propagation algorithm, its advantages and disadvantages, and the common evaluation metrics, as well as the dataset used and details of the code for the custom label propagation class.

## Community Detection
Community detection references a set of network-based machine learning techniques that identify communities in graph structures. Networks (graphs) are composed of nodes and edges (connections between nodes); community detection algorithms work by determining nodes that are more densely connected with one another, and grouping them together. Community detection can be unsupervised, aiming to discover patterns in the graph without the addition of labeled data.

## Label Propagation
Label propagation is a community detection technique that iteratively assigns labels to uniquely labeled points to form larger communities that share a label. It operates on the principle that labels will diffuse through a network, with densely connected nodes eventually sharing the same label among them.

In unsupervised community detection, each node in a network begins with a unique label. For each node in the graph (iterated through in a random and shuffled order), the most common label out of the neighboring nodes is identified and assigned to the given node. When labels are tied for the majority, one is randomly selected. As this process progresses, labels are propagated through the graph, with densely connected nodes eventually obtaining a single label that spreads through the community. Label selection continues for a specified number of iterations, or until an iteration occurs where no nodes change their label.

## Advantages and Disadvantages
Label propagation is a standard and useful community detection method, but it has several considerable disadvantages.

### Advantages
- Simple and relatively quick algorithm
- Able to scale to very large networks
- Does not require a predefined number of communities
- Can be adapted for semi-supervised learning (propagating given labels through the network)

### Disadvantages
- Results have an element of randomness and thus instability, especially due to tie-breakers
- Initial labels have a large influence on the final communities, and no unique solution is produced
- Prone to formation of trivially large communities in weakly structured graphs

## Evaluation
Label propagation can be evaluated with specific metrics. The following metrics are used:

1. *Modularity*: measures how well the network is divided into communities, calculated with NetworkX; compares the fraction of edges within a community to the expected fraction within a network generated by random edge distribution
2. *Label Visualization*: visualizes the graph with assigned labels for qualitative assessment of communities

## Code Features
Label propagation is implemented using the custom `label_propagation` class from the unsupervised learning package. The following describes the class.

1. **Label Propagation**:
- Implements a standard unsupervised label propagation algorithm
- Hyperparameters:
    - *graph*: the input NetworkX graph for the algorithm
    - *max_iter*: maximum number of iterations
    - *random_state*: random state used in tiebreakers and data shuffling
- Methods:
    - *propagation*: executes the label propagation algorithm for the input graph and returns the labels for each node

## Data Used
The dataset used for evaluating label propagation is the Cora dataset, which is a common dataset in graph or network-based machine learning. It represents scientific papers (nodes) linked by citations (edges), with a total of 2708 nodes and 5278 edges. It contains multiple connected subgraphs that are useful for label propagation and visualization, and is suitable for both unsupervised and semi-supervised learning with predefined labels (paper topics).

The label propagation algorithm attempts to detect communities in a subgraph of the dataset using unsupervised learning, without considering the original categorical labels. More information on the particular implementation of the model can be found in the associated notebook.